#3 线程间通信

## 3.1.1
通过轮训检测某一个条件，浪费CPU资源，间隔过小，更浪费CPU资源，间隔过大，取不到想要的值

## 3.1.2
多个线程读取同一变量，不是 等待/通知，主动式读取共享变量，浪费读取时间，不能确定读取的值是不是想要的

## 3.1.3
- wait调用前需要获取对象锁，没有持有适当锁，抛出IllegalMonitorStateException
- wait所在代码停止执行，直到接到通知或者中断
- wait将线程置入 预执行队列
- wait执行后，立即释放锁
- wait方法返回前，与其他线程竞争锁

- nofity调用前需要获取对象锁，没有持有适当锁，抛出IllegalMonitorStateException
- nofity用来通知可能等待该对象的对象锁的其他线程，如果多个线程等待，由线程规划器随机挑选一个呈wait状态的线程，对其发出notify通知，并使其等待获取对象锁
- notify执行后，锁不释放，必须执行完notify所在的同步synchrnoized代码块后才释放
- 第一个获得该对象锁的wait线程执行后，它会释放对象锁，如果该对象没有使用notify语句，即使该对象空闲，其他呈wait状态等待的线程由于没有收到通知，
还会阻塞在wait状态，直到这个对象发出notify
- notify执行时，没有被wait的线程，命令被忽略
- notifyAll使等待对象锁的所有线程进入可运行状态，优先级高的先执行或者随机执行，取决JVM实现

### 线程状态转换
进入Runnable 大体五种情况

1. 调用sleep后超过等待时间
2. 线程调用的阻塞IO返回，阻塞方法执行完毕
3. 线程成功获取试图同步的 监视器
4. 线程等待通知，收到了通知
5. 处于挂起的线程调用了resume方法

进入Blocked 大体五种情况

1. 调用sleep，主动放弃CPU
2. 线程调用阻塞IO
3. 线程试图获取试图同步的 监视器，但被其他线程占有
4. 线程等待通知
5. 线程调用suspend，容易死锁，避免使用

run运行结束进入销毁阶段，整个线程执行完毕


## 3.14 
执行wait()，锁自动释放，执行notify()，锁不释放，必须执行完notify所在的同步synchrnoized代码块后才释放

## 3.15
