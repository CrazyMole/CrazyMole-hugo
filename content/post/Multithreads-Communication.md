# 3 线程间通信

## 3.1.1 不使用 等待/通知 机制实现线程间通信
通过轮训检测某一个条件，浪费CPU资源，间隔过小，更浪费CPU资源，间隔过大，取不到想要的值

## 3.1.2 什么是 等待/通知 机制
多个线程读取同一变量，不是 等待/通知，主动式读取共享变量，浪费读取时间，不能确定读取的值是不是想要的

## 3.1.3 等待/通知 机制的实现

### wait
- wait调用前需要获取对象锁，没有持有适当锁，抛出IllegalMonitorStateException
- wait所在代码停止执行，直到接到通知或者中断
- wait将线程置入 预执行队列
- wait执行后，立即释放锁
- wait方法返回前，与其他线程竞争锁

### notify
- nofity调用前需要获取对象锁，没有持有适当锁，抛出IllegalMonitorStateException
- nofity用来通知可能等待该对象的对象锁的其他线程，如果多个线程等待，由线程规划器随机挑选一个呈wait状态的线程，对其发出notify通知，并使其等待获取对象锁
- notify执行后，锁不释放，必须执行完notify所在的同步synchrnoized代码块后才释放
- 第一个获得该对象锁的wait线程执行后，它会释放对象锁，如果该对象没有使用notify语句，即使该对象空闲，其他呈wait状态等待的线程由于没有收到通知，
还会阻塞在wait状态，直到这个对象发出notify
- notify执行时，没有被wait的线程，命令被忽略
- notifyAll使等待对象锁的所有线程进入可运行状态，优先级高的先执行或者随机执行，取决JVM实现

### 调用start，进入Runnable状态，抢占CPU，进入Running状态

### 进入Runnable 大体五种情况

1. 调用sleep后超过等待时间
2. 线程调用的阻塞IO返回，阻塞方法执行完毕
3. 线程成功获取试图同步的 监视器
4. 线程等待通知，收到了通知
5. 处于挂起的线程调用了resume方法

### 进入Blocked 大体五种情况

1. 调用sleep，主动放弃CPU
2. 线程调用阻塞IO
3. 线程试图获取试图同步的 监视器，但被其他线程占有
4. 线程等待通知
5. 线程调用suspend，容易死锁，避免使用

### run运行结束进入销毁阶段，整个线程执行完毕


## 3.1.4 wait锁释放与notify锁不释放
执行wait()，锁自动释放，执行notify()，锁不释放，必须执行完notify所在的同步synchrnoized代码块后才释放

## 3.1.5 interrupt遇到wait
线程wait状态，调用interrupt会出现InterruptedException

1. 执行完同步代码块 会释放锁
2. 执行同步代码块遇到异常 会释放锁
3. 执行锁所属对象的wait方法，线程释放锁，会进入线程等待池中

## 3.1.6 只通知一个线程

notify只会随机通知一个线程
多次notify方法，随机将wait状态的线程唤醒

## 3.1.7 唤醒所有线程
notify方法的次数小于 等待线程的数量，会有线程无法被唤醒
notifyAll 通知所有处于等待状态的线程

## 3.1.8 wait(long)使用
同wait，超时自动唤醒

## 3.1.9 通知过早
通知过早，顺序混乱，wait线程永远不会被唤醒，notify线程忽略

## 3.1.10
wai条件发生改变，具体案例，用while取代if，避免条件改变时没有及时相映

## 3.1.11 生产者/消费者

### 多生产 多消费 假死
如果同步同一个 对象监视器，无法保证唤醒的是异类，多生产，多消费很有可能假死，使用notifyAll解决
### 一生产/一消费
### 一生产/多消费
### 多生产/一消费
### 多生产/多消费

## 3.1.12 通过管道进行线程间通信 字节流

## 3.1.13 通过管道进行线程间通信 字符流

## 3.1.14 实战：等待/通知 之交叉备份






